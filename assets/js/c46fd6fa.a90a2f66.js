"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[8563],{4137:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,b=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return n?o.createElement(b,i(i({ref:t},d),{},{components:n})):o.createElement(b,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2177:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(7462),a=(n(7294),n(4137));const r={sidebar_position:2,sidebar_label:"Extend our voting system with backend",description:"This section will show you how you can interact with contracts from a backend."},i="Venom In Action. Extend our voting system with backend",s={unversionedId:"build/development-guides/developing-of-simple-voting-system/venom-in-action/extend-our-voting-system-with-backend",id:"build/development-guides/developing-of-simple-voting-system/venom-in-action/extend-our-voting-system-with-backend",title:"Venom In Action. Extend our voting system with backend",description:"This section will show you how you can interact with contracts from a backend.",source:"@site/docs/build/development-guides/developing-of-simple-voting-system/venom-in-action/extend-our-voting-system-with-backend.md",sourceDirName:"build/development-guides/developing-of-simple-voting-system/venom-in-action",slug:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/extend-our-voting-system-with-backend",permalink:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/extend-our-voting-system-with-backend",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Extend our voting system with backend",description:"This section will show you how you can interact with contracts from a backend."},sidebar:"buildSidebar",previous:{title:"Ways of code enhancing",permalink:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/ways-of-code-enhancing"},next:{title:"Non-Fungible tokens in Venom network",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/non-fungible-tokens-in-venom-network"}},l={},c=[{value:"Interaction with smart contracts",id:"interaction-with-smart-contracts",level:2},{value:"Listening to events of smart contract",id:"listening-to-events-of-smart-contract",level:2},{value:"Database and server stuff",id:"database-and-server-stuff",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"venom-in-action-extend-our-voting-system-with-backend"},"Venom In Action. Extend our voting system with backend"),(0,a.kt)("p",null,"We already can interact with our smart contracts via the web interface. But what about backend development? Let's implement a simple server, that will work with our smart contracts."),(0,a.kt)("p",null,"First of all, we need to target the purposes of our backend app. As you know, every deployed ballot should be activated by the voting owner. So, it will be good to store ballot addresses somewhere in a database for handy activation of them. Since we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"NewBallot")," event in our smart contract, we can listen to these events and store information from them in the database. It would be nice to have an activation method too, as well as some methods for showing stored data. And we will implement a 'lottery' method as a bonus. This method will activate random ten ballots. So, we are ready to start!"),(0,a.kt)("p",null,"For building our backend, we will use NodeJS Express stack with Typescript on a board. To store data we take SQLite, just because there is no needs to have something smarter...it is just a guide, right?"),(0,a.kt)("p",null,"We are starting with the ",(0,a.kt)("inlineCode",{parentName:"p"},"npm init")," command and installing dependencies."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"This guide will not include backend development basements, typescript and nodejs essentials. We focus our attention only on venom smart contracts integration.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm install --save express body-parser sqlite sqlite3\n")),(0,a.kt)("p",null,"Do not forget about typescript (with ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," file) and some types for our express lib."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm install --save-dev typescript @types/express\n")),(0,a.kt)("p",null,"Now it's time to see who will help us with smart contract interaction. You will be surprised, but backend libraries will be the same as frontend! Yes, these libraries are suitable for the backend too."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm install --save everscale-inpage-provider everscale-standalone-client\n")),(0,a.kt)("h2",{id:"interaction-with-smart-contracts"},"Interaction with smart contracts"),(0,a.kt)("p",null,"Let's implement a module for smart contract interaction. We need to initialize a client here"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/blockchain.ts" lineNumbers="true"',title:'"src/modules/blockchain.ts"',lineNumbers:'"true"'},"import { ProviderRpcClient } from \"everscale-inpage-provider\";\nimport { EverscaleStandaloneClient, SimpleKeystore } from \"everscale-standalone-client/nodejs\";\n\n// Key pair for interact with Ballot contract. You can explore the logic of activation in first guide of this series.\nconst ballotActivationSignerKeys = {\n  // suppose we have this variables in system environment...you can use dotenv for example\n  public: process.env.ACTIVATE_SIGNER_PUBLIC_KEY as string,\n  secret: process.env.ACTIVATE_SIGNER_SECRET_KEY as string,\n};\n\n// function for creating a standalone client\n// (of course you have to create some singleton for that)\nasync function getClient(): Promise<ProviderRpcClient> {\n  const client = new ProviderRpcClient({\n    fallback: () =>\n    EverscaleStandaloneClient.create({\n      connection: {\n        id: 1010,\n        group: 'testnet',\n        type: 'jrpc',\n        data: {\n          endpoint: 'https://jrpc-testnet.venom.foundation/rpc',\n        },\n      },\n      // Manually creating a keystore for our client, because we haven't wallet extension here...we are not in browser\n      keystore: new SimpleKeystore({\n        [ballotActivationSignerKeys.public]: {\n          publicKey: ballotActivationSignerKeys.public,\n          secretKey: ballotActivationSignerKeys.secret,\n        }\n      }),\n    }),\n  });\n  await client.ensureInitialized();\n  await client.requestPermissions({ permissions: ['basic'] });\n  return client;\n}\n")),(0,a.kt)("p",null,"Pay attention to the keystore section. This is the difference with the usage standalone-client in frontend development. You don't need to control a keystore when using inpage-provider with web, because you have a wallet extension there, that will provide a keystore for you. But backend developers should create a keystore by themselves."),(0,a.kt)("p",null,"Now we can implement an ",(0,a.kt)("inlineCode",{parentName:"p"},"activateBallot")," function here."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/blockchain.ts" lineNumbers="true"',title:'"src/modules/blockchain.ts"',lineNumbers:'"true"'},"import { Address, Contract, ProviderRpcClient } from \"everscale-inpage-provider\";\nimport { EverscaleStandaloneClient, SimpleKeystore } from \"everscale-standalone-client/nodejs\";\nimport { readFileSync } from 'fs';\nimport { resolve } from 'path';\n\n// importing an ABI here\nimport { abi as ballotContractAbi } from '../abi/Ballot.abi';\n\n...\n\n// Just a little helper. Returns a Ballot contract instance.\nfunction getBallotContract(\n  client: ProviderRpcClient,\n  address: string,\n): Contract<typeof ballotContractAbi> {\n  const contractAbi = JSON.parse(\n    readFileSync(\n      resolve(process.cwd(), 'src/abi/Ballot.abi.json'), // yes, just place it somewhere\n      'utf-8'\n    )\n  );\n  return new client.Contract(contractAbi, new Address(address));\n}\n\n// Sends an external message to Ballot, signed by Vote owner. (Ballot activation logic)\nexport async function activateBallot(ballotAddress: string): Promise<string | undefined> {\n  try {\n    const client = await getClient();\n    const ballotContract = getBallotContract(client, ballotAddress);\n    const response = await ballotContract.methods.activate({}).sendExternal({\n      publicKey: ballotActivationSignerKeys.public, // It must be in our client's keystore!!! With private!!!\n    });\n    if (response.transaction.aborted) {\n      throw new Error ('Transaction aborted');\n    }\n    return ballotAddress;\n  } catch (error) {\n    return undefined;\n  }\n}\n")),(0,a.kt)("p",null,"Same as frontend, isn't it? That is all interaction we need, except for events listening. Let's deal with this task."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"But what if I need to send an internal message from my wallet?"),(0,a.kt)("p",null,"Then you should perform some improvements. First thing - ",(0,a.kt)("inlineCode",{parentName:"p"},"accountsStorage")," parameter for client initialization. Suppose you have a ",(0,a.kt)("inlineCode",{parentName:"p"},"WalletV3")," and this is a wallet for your internal interaction. Provide wallet address and key pair somehow (this example provides it by environment variables). So your ",(0,a.kt)("inlineCode",{parentName:"p"},"getClient")," function will be like"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/blockchain.ts" lineNumbers="true"',title:'"src/modules/blockchain.ts"',lineNumbers:'"true"'},"async function getClient(): Promise<ProviderRpcClient> {\n  // initializing accounts storage\n  // SimpleAccountsStorage is a class from everscale-standalone-client\n  const accountsStorage = new SimpleAccountsStorage(); \n  // import WalletV3Account from everscale-standalone-client and provide an public key from somewhere\n  const account = await WalletV3Account.fromPubkey({\n    publicKey: process.env.MY_WALLET_ADDRESS_PUBLIC_KEY\n  })\n  // put our walletv3 to storage\n  accountsStorage.addAccount(account);\n  accountsStorage.defaultAccount = account.address;\n\n  const client = new ProviderRpcClient({\n    fallback: () =>\n      EverscaleStandaloneClient.create({\n        connection: {\n          id: 1010,\n          group: 'testnet',\n          type: 'jrpc',\n          data: {\n            endpoint: 'https://jrpc-testnet.venom.foundation/rpc',\n          },\n        },\n        accountsStorage, // provide our accounts storage here!\n        // Of course we need a keystore here! And keys exactly from our wallet!\n        keystore: new SimpleKeystore({\n          [process.env.MY_WALLET_ADDRESS]: {\n            publicKey: process.env.MY_WALLET_ADDRESS_PUBLIC_KEY,\n            secretKey: process.env.MY_WALLET_ADDRESS_SECRET_KEY,\n          },\n        }),\n      }),\n  });\n  await client.ensureInitialized();\n  await client.requestPermissions({ permissions: ['basic'] });\n  return client;\n}\n")),(0,a.kt)("p",null,"And then you can implement a ",(0,a.kt)("inlineCode",{parentName:"p"},"deployBallot")," function, for example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/blockchain.ts" lineNumbers="true"',title:'"src/modules/blockchain.ts"',lineNumbers:'"true"'},"// Same simple helper to get a Vote contract instance\n// Import an ABI files from somewhere...same as for Ballot.\nfunction getVoteContract(\n  client: ProviderRpcClient\n): Contract<typeof voteContractAbi> {\n  const contractAbi = JSON.parse(\n    readFileSync(\n      resolve(process.cwd(), 'src/abi/Vote.abi.json'),\n      'utf-8'\n    )\n  );\n  return new client.Contract(contractAbi, new Address(process.env.VOTE_CONTRACT_ADDRESS!));\n}\n\nexport async function deployBallot(futureOwner: string): Promise<string | undefined> {\n  try {\n    const client = await getClient();\n    const voteContract = getVoteContract(client);\n    // Here will be the main call\n    const response = await voteContract.methods\n      .deployBallot({ // our method and params\n        owner: new Address(futureOwner),\n        sendRemainingGasTo: new Address(deployBallotSignerAddress),\n      })\n      .sendWithResult({\n        amount: '500000000', // how much value will be attached\n        from: new Address(process.env.MY_WALLET_ADDRESS), // just like that! It will be an internal message from your wallet!\n        bounce: true,\n      });\n    const voteContractAbi = JSON.parse(\n      readFileSync(\n        resolve(process.cwd(), 'src/abi/Vote.abi.json'),\n        'utf-8'\n      )\n    );\n    const decodedResult = await client.rawApi.decodeTransactionEvents({\n      abi: JSON.stringify(voteContractAbi),\n      transaction: response.childTransaction as any,\n    });\n    if (!decodedResult.events.length) {\n      console.log('Events was not found in child transaction');\n      return undefined;\n    }\n    const eventData = decodedResult.events.find(event => event.event === 'NewBallot')?.data as NewBallotData;\n    return eventData.ballotAddress;\n  } catch (error) {\n    console.log(`Deploy ballot error`, (error as any).stack);\n    return undefined;\n  }\n}\n")),(0,a.kt)("p",null,"That is the way to deal with sending internal messages from your wallet to another contract. From backend service!")),(0,a.kt)("h2",{id:"listening-to-events-of-smart-contract"},"Listening to events of smart contract"),(0,a.kt)("p",null,"Let's implement a smart contract event handler. We can do it with everscale-inpage-provider. It will be just a function, that will be instantiated in the express ",(0,a.kt)("inlineCode",{parentName:"p"},"listen")," method a little bit later."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/blockchain.ts" lineNumbers="true"',title:'"src/modules/blockchain.ts"',lineNumbers:'"true"'},"import { Address, Contract, ProviderRpcClient, Subscriber } from \"everscale-inpage-provider\";\nimport { EverscaleStandaloneClient, SimpleKeystore } from \"everscale-standalone-client/nodejs\";\nimport { readFileSync } from 'fs';\nimport { resolve } from 'path';\n\n// importing an ABI here\nimport { abi as ballotContractAbi } from '../abi/Ballot.abi';\nimport { abi as voteContractAbi } from '../abi/Vote.abi';\n\n...\n\n// Just a little helper. Returns a Vote contract instance.\nfunction getVoteContract(\n  client: ProviderRpcClient\n): Contract<typeof voteContractAbi> {\n  const contractAbi = JSON.parse(\n    readFileSync(\n      resolve(process.cwd(), 'src/abi/Vote.abi.json'),\n      'utf-8'\n    )\n  );\n  return new client.Contract(contractAbi, new Address(process.env.VOTE_CONTRACT_ADDRESS!));\n}\n\n// NewBallot event listener (Vote contract)\nexport async function listenNewBallotEvent() {\n  const client = await getClient();\n  const voteContract = getVoteContract(client);\n  \n  const subscriber = new Subscriber(client);\n  voteContract\n    .events(subscriber)\n    .filter((event) => event.event === 'NewBallot')\n    .on(async (event) => {\n      // here is our event\n      const eventData = {\n        ballotAddress: event.data.ballotAddress.toString(),\n        owner: event.data.owner.toString(),\n      };\n      // here we will implement a saving to database\n    })\n  console.log(`Subscribed to NewBallot`);\n}\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You can accept the same ideas for your frontend app, just because we are using the same libraries.")),(0,a.kt)("h2",{id:"database-and-server-stuff"},"Database and server stuff"),(0,a.kt)("p",null,"We are not going to analyze some NodeJS Express features and SQLite here in details. Just move on straight to code snippets. Start with database stuff."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/database.ts" lineNumbers="true"',title:'"src/modules/database.ts"',lineNumbers:'"true"'},"import { open } from 'sqlite';\nimport sqlite3 from 'sqlite3';\n\n// helper for returning a connection to our sqlite\nexport async function getConnection() {\n  return open({\n    filename: `/tmp/${process.env.DB_DATABASE}.db`,\n    driver: sqlite3.cached.Database\n  })\n};\n\n// Here we will initialize or ballot table. Just store ballot address and it's owner there\n// We will call this right after express initialization.\nexport async function initDB() {\n  const db = await getConnection();\n  db.on('trace', (data: any) => {\n    console.log('SQL trace:', data);\n  });\n  await db.exec(`\n    CREATE TABLE IF NOT EXISTS ballots(\n      id INTEGER PRIMARY KEY NOT NULL,\n      address varchar(66) NOT NULL UNIQUE,\n      owner varchar(66) NOT NULL UNIQUE\n    )\n  `);\n  console.log('DB initialized!');\n}\n")),(0,a.kt)("p",null,"OK. Now move to express router stuff:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/modules/api.ts" lineNumbers="true"',title:'"src/modules/api.ts"',lineNumbers:'"true"'},"import { Router } from \"express\";\nimport { getConnection } from \"./database\";\nimport { activateBallot } from \"./blockchain\";\n\n// initialize express router, we will use it later\nexport const ballotsRouter = Router();\n\n// returns a list with all stored ballots\nballotsRouter.get(\"/\", async function (req, res) {\n  const connection = await getConnection();\n  const ballots = await connection.all<any[]>('SELECT * FROM ballots');\n  res.json(ballots);\n});\n\n// ballot activation by owner's address\n// body = {owner: <address>}\nballotsRouter.post(\"/ballot/activate\", async function (req, res) {\n  const connection = await getConnection();\n  const ballot = await connection.get<any>(`SELECT * FROM ballots WHERE owner = '${req.body.owner}'`);\n  if (!ballot) {\n    return res.status(404).json({ success: false, message: 'Ballot not found' });\n  }\n  // this is a function we implemented in blockchain module\n  const result = await activateBallot(ballot.address);\n  if (!result) {\n    return res.status(400).json({ success: false, message: 'Can not activate ballot' });\n  }\n  res.json(ballot);\n});\n\n// bonus method! Activation of random ten ballots!\nballotsRouter.post(\"/lottery\", async function (req, res) {\n  const connection = await getConnection();\n  const ballots = await connection.all<any[]>('SELECT * FROM ballots ORDER BY RANDOM() LIMIT 10');\n  const promises = [];\n  for (const ballot of ballots) {\n    promises.push(activateBallot(ballot.address));\n  }\n  const results = await Promise.allSettled(promises);\n  const response = { \n    results: results\n      .filter(res => res.status === 'fulfilled')\n      .map(x => (x as PromiseFulfilledResult<any>).value)\n    ,\n    activatedSuccessfully: results.filter(\n      res => res.status === 'fulfilled' && (res as PromiseFulfilledResult<any>)?.value\n    ).length,\n  };\n  res.json(response);\n});\n")),(0,a.kt)("h2",{id:"putting-it-all-together"},"Putting it all together"),(0,a.kt)("p",null,"The finishing touch - main script with our express server initialization."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/index.ts" lineNumbers="true"',title:'"src/index.ts"',lineNumbers:'"true"'},"import express, { Express } from 'express';\nimport * as bodyParser from 'body-parser';\nimport { initDB } from './modules/database';\nimport * as api from './modules/api';\nimport { listenNewBallotEvent } from './modules/blockchain';\n\nconsole.log('Running app..');\n\n// express initializing\nconst app: Express = express();\napp.use(bodyParser.json())\n// our api controller\napp.use('/ballots', api.ballotsRouter);\n\napp.listen(process.env.PORT, async () => {\n  // db initialization by our script\n  await initDB();\n  // NewBallot event handler\n  await listenNewBallotEvent();\n  console.log(`Example app listening on port ${process.env.PORT}`)\n})\n")),(0,a.kt)("p",null,"That's all. Just host it and congratulations! Now you can interact with your smart contract from the backend application!"),(0,a.kt)("p",null,"Remember, that it's just an example and not production code. We didn't keep in mind some best practices and features. You can check out the implementation of this example with some styles and features in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/vote-backend"},"repository"),"."))}p.isMDXComponent=!0}}]);