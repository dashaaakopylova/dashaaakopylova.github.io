"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[8514],{4137:(n,e,t)=>{t.d(e,{Zo:()=>l,kt:()=>p});var o=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,o,r=function(n,e){if(null==n)return{};var t,o,r={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var c=o.createContext({}),d=function(n){var e=o.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},l=function(n){var e=d(n.components);return o.createElement(c.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},m=o.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,c=n.parentName,l=s(n,["components","mdxType","originalType","parentName"]),m=d(t),p=r,f=m["".concat(c,".").concat(p)]||m[p]||u[p]||a;return t?o.createElement(f,i(i({ref:e},l),{},{components:t})):o.createElement(f,i({ref:e},l))}));function p(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=n,s.mdxType="string"==typeof n?n:r,i[1]=s;for(var d=2;d<a;d++)i[d]=t[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7166:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=t(7462),r=(t(7294),t(4137));const a={sidebar_position:2,sidebar_label:"Frontend for NFT auction",description:"This section will demonstare "},i="Venom In Action. Frontend for NFT auction",s={unversionedId:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-auction",id:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-auction",title:"Venom In Action. Frontend for NFT auction",description:"This section will demonstare ",source:"@site/docs/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-auction.md",sourceDirName:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action",slug:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-auction",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-auction",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Frontend for NFT auction",description:"This section will demonstare "},sidebar:"buildSidebar",previous:{title:"Frontend for NFT collection",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-collection"},next:{title:"How to connect Dapp UI to Venom",permalink:"/build/integration-guides/how-to-connect-dapp-ui-to-venom"}},c={},d=[{value:"Starting with React and Venom Connect",id:"starting-with-react-and-venom-connect",level:2},{value:"Working with TIP-3 TokenWallet",id:"working-with-tip-3-tokenwallet",level:2},{value:"Displaying Auction information",id:"displaying-auction-information",level:2},{value:"Auction Participation",id:"auction-participation",level:2}],l={toc:d};function u(n){let{components:e,...t}=n;return(0,r.kt)("wrapper",(0,o.Z)({},l,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"venom-in-action-frontend-for-nft-auction"},"Venom In Action. Frontend for NFT auction"),(0,r.kt)("p",null,"During this series, we wrote auction smart contracts. So with this guide, we will build a simple dapp for our NFT auction. Previous guides already showed us how to interact with smart contracts, but here we will check one of the most popular mechanics - sending fungible tokens (TIP-3)."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This guide will not include frontend development basements and React essentials. We focus our attention only on venom smart contracts integration.")),(0,r.kt)("h2",{id:"starting-with-react-and-venom-connect"},"Starting with React and Venom Connect"),(0,r.kt)("p",null,"For building a web interface, we will use ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React")," library. Of course, you can use any library you want. We are starting with the command, that allows us to scaffold React application"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"npx create-react-app nft-auction-web --template typescript\n")),(0,r.kt)("p",null,"One of the previous frontend guides has a ",(0,r.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/extend-our-tokensale-with-frontend#connecting-venom-wallet-to-your-app"},"section")," where we reviewed the venom-connect library in detail. So let's create a venom-connect initialization function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/venom-connect/configure.ts" lineNumbers="true"',title:'"src/venom-connect/configure.ts"',lineNumbers:'"true"'},"import { VenomConnect } from 'venom-connect';\nimport { ProviderRpcClient } from 'everscale-inpage-provider';\nimport { EverscaleStandaloneClient } from 'everscale-standalone-client';\n\nexport const initVenomConnect = async () => {\n  return new VenomConnect({\n    theme: 'dark',\n    checkNetworkId: 1010,\n    providersOptions: {\n      venomwallet: {\n        walletWaysToConnect: [\n          {\n            package: ProviderRpcClient,\n\n            packageOptions: {\n              fallback: VenomConnect.getPromise('venomwallet', 'extension') || (() => Promise.reject()),\n              forceUseFallback: true,\n            },\n            packageOptionsStandalone: {\n              fallback: () =>\n                EverscaleStandaloneClient.create({\n                  connection: {\n                    id: 1010,\n                    group: 'venom_testnet',\n                    type: 'jrpc',\n                    data: {\n                      endpoint: 'https://jrpc-testnet.venom.foundation/rpc',\n                    },\n                  },\n                }),\n              forceUseFallback: true,\n            },\n\n            id: 'extension',\n            type: 'extension',\n          },\n        ],\n        defaultWalletWaysToConnect: [\n          'mobile',\n          'ios',\n          'android',\n        ],\n      },\n    },\n  });\n};\n")),(0,r.kt)("p",null,"Now we call the initialization function from our main app file and pass the VenomConnect instance to our Main page:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/App.tsx" lineNumbers="true"',title:'"src/App.tsx"',lineNumbers:'"true"'},"import React, { useEffect, useState } from 'react';\nimport './styles/main.css';\n\nimport { VenomConnect } from 'venom-connect';\nimport { initVenomConnect } from './venom-connect/connector';\nimport Main from './pages/Main';\n\nfunction App() {\n  const [venomConnect, setVenomConnect] = useState<VenomConnect | undefined>();\n  const init = async () => {\n    const _venomConnect = await initVenomConnect();\n    setVenomConnect(_venomConnect);\n  };\n  useEffect(() => {\n    init();\n  }, []);\n  return <Main venomConnect={venomConnect} />;\n}\n\nexport default App;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/pages/Main.tsx" lineNumbers="true"',title:'"src/pages/Main.tsx"',lineNumbers:'"true"'},"import React, { useEffect, useState } from 'react';\nimport { VenomConnect } from 'venom-connect';\n\ntype Props = {\n  venomConnect: VenomConnect | undefined;\n};\n\nfunction Main({ venomConnect }: Props) {\n    return (\n        <div className=\"App\">\n        </div>\n    );\n}\n\nexport default Main;\n")),(0,r.kt)("p",null,"Let's create a button for connecting the venom wallet. When the user is connected, we should show the user's address, so let's create something like a web app menu header."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/pages/Main.tsx" lineNumbers="true"',title:'"src/pages/Main.tsx"',lineNumbers:'"true"'},"import React, { useEffect, useState } from 'react';\nimport { VenomConnect } from 'venom-connect';\nimport { ProviderRpcClient } from 'everscale-inpage-provider';\n\ntype Props = {\n  venomConnect: VenomConnect | undefined;\n};\n\nfunction Main({ venomConnect }: Props) {\n  const [venomProvider, setVenomProvider] = useState<any>();\n  const [standaloneProvider, setStandAloneProvider] = useState<ProviderRpcClient | undefined>();\n  const [address, setAddress] = useState();\n  // This method allows us to gen a wallet address from inpage provider\n  const getAddress = async (provider: any) => {\n    const providerState = await provider?.getProviderState?.();\n    return providerState?.permissions.accountInteraction?.address.toString();\n  };\n  // Any interaction with venom-wallet (address fetching is included) needs to be authentificated\n  const checkAuth = async (_venomConnect: any) => {\n    const auth = await _venomConnect?.checkAuth();\n    if (auth) await getAddress(_venomConnect);\n  };\n  // Method for getting a standalone provider from venomConnect instance\n  const initStandalone = async () => {\n    const standalone = await venomConnect?.getStandalone();\n    setStandAloneProvider(standalone);\n  };\n  // Handling click of login button. We need to call connect method of out VenomConnect instance, this action will call other connect handlers\n  const onLogin = async () => {\n    if (!venomConnect) return;\n    await venomConnect.connect();\n  };\n  // This handler will be called after venomConnect.login() action\n  // connect method returns provider to interact with wallet, so we just store it in state\n  const onConnect = async (provider: any) => {\n    setVenomProvider(provider);\n    await onProviderReady(provider);\n  };\n  // This handler will be called after venomConnect.disconnect() action\n  // By click logout. We need to reset address and balance.\n  const onDisconnect = async () => {\n    venomProvider?.disconnect();\n    setAddress(undefined);\n  };\n  // When our provider is ready, we need to get address and balance from.\n  const onProviderReady = async (provider: any) => {\n    const venomWalletAddress = provider ? await getAddress(provider) : undefined;\n    setAddress(venomWalletAddress);\n  };\n  useEffect(() => {\n    // connect event handler\n    const off = venomConnect?.on('connect', onConnect);\n    if (venomConnect) {\n      initStandalone();\n      checkAuth(venomConnect);\n    }\n    // just an empty callback, cuz we don't need it\n    return () => {\n      off?.();\n    };\n  }, [venomConnect]);\nreturn (\n    <div className=\"box\">\n      <header>\n        {address ? (\n          <>\n            {' '}\n            <p>{address}</p>\n            <a className=\"logout\" onClick={onDisconnect}>\n              Logout\n            </a>\n          </>\n        ) : (\n          <a className=\"btn\" onClick={onLogin}>\n            Connect wallet\n          </a>\n        )}\n      </header>\n    </div>\n  );\n}\nexport default Main;\n")),(0,r.kt)("h2",{id:"working-with-tip-3-tokenwallet"},"Working with TIP-3 TokenWallet"),(0,r.kt)("p",null,"Let's add some methods for working with TIP-3 TokenWallet. We have worked on this case already in ",(0,r.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/extend-our-tokensale-with-frontend#reading-the-users-token-balance-from-deployed-smart-contract"},"tokensale")," guide. We need to get connected user's TokenWallet address and check its balance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/pages/Main.tsx" lineNumbers="true"',title:'"src/pages/Main.tsx"',lineNumbers:'"true"'},"import React, { useEffect, useState } from 'react';\nimport { VenomConnect } from 'venom-connect';\nimport { Address, ProviderRpcClient } from 'everscale-inpage-provider';\n...\n// Do not forget about ABI. We need it to call our smart contracts!\nimport tokenRootAbi from '../abi/TokenRoot.abi.json';\nimport tokenWalletAbi from '../abi/TokenWallet.abi.json';\n// Store it somwhere....for example in separate files for constants\nimport { TOKEN_ROOT_ADDRESS } from '../utils/constants';\n\nfunction Main({ venomConnect }: Props) {\n  ...\n  // User's token (TIP-3) balance\n  const [balance, setBalance] = useState<string | undefined>();\n  // User's TokenWallet (TIP-3) address\n  const [tokenWalletAddress, setTokenWalletAddress] = useState<string | undefined>();\n  ...\n  // This method calls balance function of deployed TokenWallet smart contract (can be called with standalone client as provider)\n  const getTokenWalletAddress = async (\n    provider: ProviderRpcClient,\n    userWalletAddress: string\n  ): Promise<string | undefined> => {\n    const contract = new provider.Contract(tokenRootAbi, new Address(TOKEN_ROOT_ADDRESS));\n    const tokenWallet = (await contract.methods\n      .walletOf({\n        answerId: 0,\n        walletOwner: userWalletAddress,\n      } as never)\n      .call()) as any;\n    if (!tokenWallet) return undefined;\n    return tokenWallet.value0._address;\n  };\n  // updating of user's TIP-3 balance\n  const updateBalance = async () => {\n    if (!tokenWalletAddress || !standaloneProvider) return;\n    try {\n      const contract = new standaloneProvider.Contract(tokenWalletAbi, new Address(tokenWalletAddress));\n      // We check a contract state here to acknowledge if TokenWallet already deployed\n      // As you remember, wallet can be deployed with first transfer on it.\n      // If our wallet isn't deployed, so it's balance is 0 :)\n      const contractState = await venomProvider.rawApi.getFullContractState({ address: tokenWalletAddress });\n      if (contractState.state) {\n        // But if this deployed, just call a balance function\n        const result = (await contract.methods.balance({ answerId: 0 } as never).call()) as any;\n        const tokenBalance = result.value0;\n        // formatBalance is just a beauty helper to divide our balance by 10 ** 9 (decimals...our TIP-3 decimals is 9)\n        setBalance(formatBalance(tokenBalance));\n      } else {\n        setBalance('0');\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  // updating of user's TokenWallet (TIP-3) address (placed in hook)\n  const updateTokenWalletAddress = async (provider: ProviderRpcClient, userWalletAddress: string) => {\n    if (tokenWalletAddress) return;\n    const walletAddress = await getTokenWalletAddress(provider, userWalletAddress);\n    setTokenWalletAddress(walletAddress);\n  };\n  ...\n  // two hooks to init connected user's TokenWallet address and balance.\n  useEffect(() => {\n    if (address && standaloneProvider) {\n      updateTokenWalletAddress(standaloneProvider, address);\n    }\n  }, [address]);\n  useEffect(() => {\n    if (tokenWalletAddress) updateBalance();\n  }, [tokenWalletAddress]);\n  ...\n")),(0,r.kt)("p",null,"This is enough for our task. Let's implement a component, that will show us the auction info."),(0,r.kt)("h2",{id:"displaying-auction-information"},"Displaying Auction information"),(0,r.kt)("p",null,"Let's implement a component, filled with all the auction data we need. Here is nothing special to show. We need just to read a smart contract state, so let's implement a full listing immediately:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/components/NftAuction.tsx" lineNumbers="true"',title:'"src/components/NftAuction.tsx"',lineNumbers:'"true"'},"import React, { useEffect, useState } from 'react';\nimport { Address, ProviderRpcClient } from 'everscale-inpage-provider';\nimport { BaseNftJson, formatBalance, formatDate } from '../utils/helpers';\n\n// Do not forget about ABI. We need it to call our smart contracts!\nimport auctionAbi from '../abi/Auction.abi.json';\nimport nftAbi from '../abi/NFT.abi.json';\n// Store it somwhere....for example in separate files for constants\nimport { AUCTION_ADDRESS } from '../utils/constants';\n\ntype Props = {\n  address: string | undefined;\n  balance: string | undefined;\n  standaloneProvider: ProviderRpcClient | undefined;\n  venomProvider: ProviderRpcClient | undefined;\n  tokenWalletAddress: string | undefined;\n  checkBalance: () => void;\n};\ntype NftAnswer = {\n  _nft: Address;\n};\n// uncommented get methods of this component are obvious\nfunction NftAuction({ address, balance, standaloneProvider, venomProvider, tokenWalletAddress, checkBalance }: Props) {\n  const auctionContract = standaloneProvider\n    ? new standaloneProvider.Contract(auctionAbi, new Address(AUCTION_ADDRESS))\n    : undefined;\n  // Some state variables from Auction smart contract. You can just check ABI.\n  const [nftUrl, setNftUrl] = useState<string | undefined>();\n  const [currenBid, setCurrentBid] = useState<string | undefined>();\n  const [currentWinner, setCurrentWinner] = useState<string | undefined>();\n  const [endTime, setEndTime] = useState<string | undefined>();\n  const [needUpdate, setNeedUpdate] = useState(false);\n  const getNftAddress = async (): Promise<Address | undefined> => {\n    if (!auctionContract) return undefined;\n    const answer = (await auctionContract.methods._nft({} as never).call()) as NftAnswer;\n    if (!answer) return undefined;\n    return answer._nft;\n  };\n  // we need to read the NFT contract here to get NFT itself (NFT data json)\n  const getNftUrl = async (provider: ProviderRpcClient, nftAddress: Address): Promise<string> => {\n    const nftContract = new provider.Contract(nftAbi, nftAddress);\n    const result = (await nftContract.methods.getJson({ answerId: 0 } as never).call()) as { json: string };\n    const json = JSON.parse(result.json ?? '{}') as BaseNftJson;\n    return json.preview?.source || '';\n  };\n  // loadNFT - get NFT address from Auction contract and get data from NFT contract\n  const loadNft = async (provider: ProviderRpcClient) => {\n    const nftAddress = await getNftAddress();\n    if (!nftAddress) return;\n    const _nftUrl = await getNftUrl(provider, nftAddress);\n    if (!_nftUrl) return;\n    setNftUrl(_nftUrl);\n  };\n  const getCurrentBid = async (): Promise<string | undefined> => {\n    if (!auctionContract) return undefined;\n    const { _currentBid } = await auctionContract.methods._currentBid({} as never).call();\n    return formatBalance(_currentBid) || '0';\n  };\n  const getCurrentWinner = async (): Promise<string | undefined> => {\n    if (!auctionContract) return undefined;\n    const result = (await auctionContract.methods._currentWinner({} as never).call()) as any;\n    return result._currentWinner._address;\n  };\n  const getEndTime = async (): Promise<string | undefined> => {\n    if (!auctionContract) return undefined;\n    const { _endTime } = await auctionContract.methods._endTime({} as never).call();\n    return formatDate(_endTime);\n  };\n  // Bring it all together :) We need it for hook\n  const loadAuctionInfo = async (provider: ProviderRpcClient) => {\n    try {\n      await loadNft(provider);\n      const _currentBid = await getCurrentBid();\n      setCurrentBid(_currentBid);\n      const _currentWinner = await getCurrentWinner();\n      setCurrentWinner(_currentWinner);\n      const _endTime = await getEndTime();\n      setEndTime(_endTime);\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  const updateData = async () => {\n    await checkBalance();\n    const _currentBid = await getCurrentBid();\n    setCurrentBid(_currentBid);\n    const _currentWinner = await getCurrentWinner();\n    setCurrentWinner(_currentWinner);\n    setNeedUpdate(false);\n  };\n  // Main hooks for loading and updating our info\n  useEffect(() => {\n    if (standaloneProvider) loadAuctionInfo(standaloneProvider);\n  }, [standaloneProvider]);\n  useEffect(() => {\n    if (needUpdate && standaloneProvider) updateData();\n  }, [needUpdate]);\n  return (\n    <div className=\"card\">\n      <div className=\"card__wrap\">\n        <h1>My Venom NFT Auction</h1>\n        <div className=\"item-info\">\n          <span>Ends:</span>\n          {endTime && <b>{endTime} UTC</b>}\n        </div>\n        {nftUrl && <img src={nftUrl} alt=\"nft\" />}\n        <div className=\"info-group\">\n          <div className=\"item-info\">\n            <span>Last Bid</span>\n            {currenBid && <b>{currenBid} TST</b>}\n          </div>\n          <div className=\"item-info item-info_copy\">\n            {currentWinner && <p id=\"copyText\">{currentWinner}</p>}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\nexport default NftAuction;\n")),(0,r.kt)("p",null,"Hope that we consolidated the reading from a smart contract with this component :)"),(0,r.kt)("p",null,"The last thing we need to implement - is the possibility to participate in the auction"),(0,r.kt)("h2",{id:"auction-participation"},"Auction Participation"),(0,r.kt)("p",null,"As we remember from our ",(0,r.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction"},"smart contracts")," logic, we need just to send TIP-3 tokens to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Auction")," contract. So we need to implement a component for this logic...just a form. How to send TIP-3 tokens somewhere? Just call a ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," method of the user's ",(0,r.kt)("inlineCode",{parentName:"p"},"TokenWalet")," contract. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/components/AuctionSendForm.tsx" lineNumbers="true"',title:'"src/components/AuctionSendForm.tsx"',lineNumbers:'"true"'},"import React, { useState } from 'react';\nimport { Address, ProviderRpcClient } from 'everscale-inpage-provider';\n// this helper is doing just multiplying by 10 ** 9 (decimals)\nimport { getValueForSend } from '../utils/helpers';\n\n// Do not forget about ABI. We need it to call our smart contracts!\nimport tokenWalletAbi from '../abi/TokenWallet.abi.json';\n// Store it somwhere....for example in separate files for constants\nimport { AUCTION_ADDRESS } from '../utils/constants';\n\ntype Props = {\n  address: string;\n  balance: string | undefined;\n  venomProvider: ProviderRpcClient | undefined;\n  tokenWalletAddress: string;\n  setNeedUpdate: (value: boolean) => void;\n};\nfunction AuctionSendForm({ address, balance, venomProvider, tokenWalletAddress, setNeedUpdate }: Props) {\n  // amount of tokens to bet with helpers to increase/decrease it and change\n  // we need it just for our layout (input firld with increase/decrease buttons)\n  const [tokenAmount, setTokenAmount] = useState<number | undefined>(0);\n  const increaseAmount = () => {\n    if (!tokenAmount && Number(balance) >= 1) {\n      setTokenAmount(1);\n    } else if (tokenAmount && tokenAmount + 1 <= Number(balance)) setTokenAmount(tokenAmount + 1);\n  };\n  const decreaseAmount = () => {\n    if (!tokenAmount || tokenAmount <= 0) return;\n    setTokenAmount(tokenAmount - 1);\n  };\n  const onChangeAmount = (e: string) => {\n    if (e === '') setTokenAmount(undefined);\n    if (Number(e) <= Number(balance)) setTokenAmount(Number(e));\n  };\n  // main function of all dAPP! :)\n  const bet = async () => {\n    try {\n      if (!venomProvider || !tokenAmount) return;\n      // TokenWallet address was passed here from somewhere (from NftAuction component)\n      const tokenWalletContract = new venomProvider.Contract(tokenWalletAbi, new Address(tokenWalletAddress));\n      // Just a common call of smart contract, nothing special and pretty easy\n      // The only one difference - usage of .send() function\n      // When we use send(), firstly we call our venom wallet (logged user's wallet) and then venom wallet will call our target contract internally (by sendTransaction method)\n      // So you need to call send() when you own callee internally (by wallet address)\n      const result = await tokenWalletContract.methods\n        .transfer({\n          amount: getValueForSend(tokenAmount),\n          recipient: new Address(AUCTION_ADDRESS),\n          deployWalletValue: 0,\n          remainingGasTo: new Address(address),\n          notify: true,\n          payload: '',\n        } as never)\n        .send({ from: new Address(address), amount: getValueForSend(1), bounce: true });\n      if (result?.id?.lt && result?.endStatus === 'active') {\n        // when our tx is success we need to refresh parent component with new data\n        setNeedUpdate(true);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  return (\n    <>\n      <div className=\"item-info item-info_mt\">\n        <span>My Token Balance</span>\n        <b>{balance}</b>\n      </div>\n      <div className=\"card__amount\">\n        <div className=\"number\">\n          <span>Amount</span>\n          <button className=\"number__minus\" type=\"button\" onClick={decreaseAmount} />\n          <input\n            type=\"number\"\n            min={0}\n            value={tokenAmount !== undefined ? tokenAmount : ''}\n            onChange={(e) => {\n              onChangeAmount(e.target.value);\n            }}\n          />\n          <button className=\"number__plus\" type=\"button\" onClick={increaseAmount} />\n        </div>\n        <a className={!tokenAmount ? 'btn disabled' : 'btn'} onClick={bet}>\n          Bid\n        </a>\n      </div>\n    </>\n  );\n}\n\nexport default AuctionSendForm;\n")),(0,r.kt)("p",null,"Then we need to place this form component to our previous NftAuction component and pass variables, that were passed from the Main page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/components/NftAuction.tsx" lineNumbers="true"',title:'"src/components/NftAuction.tsx"',lineNumbers:'"true"'},'import React, { useEffect, useState } from \'react\';\n...\nimport AuctionSendForm from \'./AuctionSendForm\';\n...\nfunction NftAuction({ address, balance, standaloneProvider, venomProvider, tokenWalletAddress, checkBalance }: Props) {\n  ...\n  return (\n    <div className="card">\n      <div className="card__wrap">\n        <h1>My Venom NFT Auction</h1>\n        <div className="item-info">\n          <span>Ends:</span>\n          {endTime && <b>{endTime} UTC</b>}\n        </div>\n        {nftUrl && <img src={nftUrl} alt="nft" />}\n        <div className="info-group">\n          <div className="item-info">\n            <span>Last Bid</span>\n            {currenBid && <b>{currenBid} TST</b>}\n          </div>\n          <div className="item-info item-info_copy">\n            {currentWinner && <p id="copyText">{currentWinner}</p>}\n          </div>\n        </div>\n        {address && tokenWalletAddress && (\n          <AuctionSendForm\n            address={address}\n            balance={balance}\n            venomProvider={venomProvider}\n            tokenWalletAddress={tokenWalletAddress}\n            setNeedUpdate={setNeedUpdate}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\nexport default NftAuction;\n')),(0,r.kt)("p",null,"That's all. Build your app, host it and congratulations! Now you try to perform one of the most popular actions - sending non-fungible tokens from dapp."),(0,r.kt)("p",null,"Remember, that it's just an example and not production code. We didn't keep in mind some loaders and state managers. Also, we didn't implement some traction of other users' behavior (updating of page, when someone has placed a bid). You can check out the implementation of this example with some styles and features in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/nft-auction-frontend"},"repository"),"."))}u.isMDXComponent=!0}}]);